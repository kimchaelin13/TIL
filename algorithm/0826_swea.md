## swea_1218_괄호

```python
for tc in range(1,11):
    leng = int(input())
    bracket = input()
    stack=[]

    for i in range(leng):
        if bracket[i] == '(' or bracket[i] == '[' or bracket[i] == '{' or bracket[i] == '<':
            stack.append(bracket[i])
        elif bracket[i] == ')' or bracket[i] == ']' or bracket[i] == '}' or bracket[i] == '>':
            if len(stack)==0:
                result = 0
                break
            else:
                tmp = stack.pop(-1)

            if bracket[i] == ')' and tmp== '(':
                continue
            elif bracket[i] == ']' and tmp== '[':
                continue
            elif bracket[i] == '}' and tmp== '{':
                continue
            elif bracket[i] == '>' and tmp== '<':
                continue
            result=0 #1

    if len(stack) > 0:
        result=0
    else: result=1

    print('#{} {}'.format(tc, result))
```

- #1 답이 안나옴 전부다 1이 나와요. 그런데 코드에서 뭐가 잘못됐는지 잘 모르겠어요
- #1은 else: result=0이 생략된게 맞나요? 







## swea_1210_Ladder1

> 사다리 문제, 진짜 문제이해 너무 안되서 어떻게 접근해야할지 너무 어려웠다. 결국 다른 사람의 코드를 보고  완전히 이해하는지도 엄청난 시간이 걸렸다 ㅎ 어쨌든 힌트를 보지 않고 코드를 작성해서 제출했다. 내일도 다시 해봐야지
>
> ref : https://mungto.tistory.com/232
>
> 이 문제에서 핵심 포인트는 하나씩 찾으면서 2를 찾을 수 있는지 없는지 보는게 아니라, 찾아야 하는 목표값인 2에서부터 시작해서 사다리가 있는 (1이표시) 곳을 타고 올라오면서 첫번째 행에서 어디 인덱스에 있는지 찾는것이다!!  

```python
for tc in range(1,11):
    test = int(input())
    ladder = [list(map(int,input().split())) for _ in range(100)] #1
    dy=99  #2
    dx=ladder[99].index(2) #3
    move=0 #4
    while dy>0: #5
        #left
        #6
        if (move==3 or move==1) and dx>0 and ladder[dy][dx-1]:
            move=1 #7
            dx -=1 #8
        	
        #right
        #9
        elif (move==3 or move==2) and dx<99 and ladder[dy][dx+1]:
            move=2 #10
            dx+=1
        
        #up
        #11
        else:
            move=3
            dy-=1
   print('#{} {}'.format(tc, dx))
```



#1 : ladder을 받아준다. 2차원 배열 입력

#2 : dy는 가장 마지막 행부터 올라올거라서 초기값을 99라고 설정함(100*100 이기 때문에, 실제로 인덱스는 0~99니까 마지막이 99줄임)

#3 : dx는 그 마지막줄에서 2가 어디 있는지를! 그게 초기값임. 문제 접근자체를 2가 어디있는지부터 찾는거임. 나중에 이걸 출력할건데 그건 첫번째 행에서의 dx를 꺼내는거야

#4 : move가 진짜 왜 해야하는지 이해가 ㄹㅇ안됐다. 이 move는 어디서 이동했는지 알려주기 위함이다. 맨 아래 줄의 2가 있는 인덱스부터 왼쪽,오른쪽,위를 탐색하면서 올라오는데 위갔다가 다시 위로 가거나 오른쪽갔다가 위로가거나  왼쪽갔다가 위로 가는건 상관없지만, 오른쪽을 갔는데 다시 왼쪽을 가면 안된다.(0 1 1 이런식으로 되있고 내가 1에 있으면 그 위치에서 오른쪽, 왼쪽을 다 탐색하는거다. 오른쪽으로 이동했는데, 다시 그 자리에서 왼쪽을 다시 탐색할 이유가 없다. 이미 탐색했던 자리이므로. ) 마찬가지로 (1 1 0 이런식이면 0에서 출발해서 1 1 로 이동했는데 첫번째 1에 와서 다시 왼쪽으로 이동할 이유가 없다)

따라서 오른쪽으로 이동했으면 오른쪽 또는 위만, 왼쪽으로 이동했으면 왼쪽 또는 위만! 가게 하기 위해 move를 넣은것임. 이게 없으면 무한 좌우반복을 하게 될수 있다.

#5 : 반복을 언제까지 하냐면 dy가 0보다 클때까지!!! dy=0이면 빠져나옴

#6 : (여기서 놀랍게도 처음 안 사실;; 조건문 쓸때 순서가 의미있었다. 그냥 and 나 or를 줄때 그냥 막 주다가 답 안나와서 순서를 바꿨는데 실행됐다.) 처음은 left탐색임. 왼쪽으로 계속 갈건데 당연히 dx가 0보다 작아지면 안되니까, 0보다 크고, 또 그 왼쪽으로 갈때 0이 아닌 사다리 값,즉 1이 있어야 하니까 `ladder[dy][dx-1]` 이걸 쓰는거고(0이 아니면 True임) 그리고 왼쪽으로 가면 move=1 을 줄거라서 그 전값이 move=0이거나 move=1이라는 건 그전에 위에서 이동했거나 또는 왼쪽으로 이동했거나 그뜻임. 어쨌든 위에서 올라왔거나 또는 왼쪽에서 온것만 이동가능함. 

#7: 왼쪽으로 이동하고, 이동을 기억하기 위해 move=1로 (이건 1,2,3 이건 임의로 설정함)

#8: 인덱스 값을 왼쪽인 -로  해줌! 이동시켜줌

#9: 오른쪽도 똑같다. move변수가 오른쪽에서 왔거나 또는 위에서 온것만 체크하면 되니까 조건문을 쓰고, 또 오른쪽으로 가기 때문에 dx값이 +되는데 99가 넘으면 안된다. 그리고 오른쪽으로 이동된 값에 1이 있어야 하므로 마지막 조건 추가 

#10 : 역시 오른쪽으로 왔다는 걸 기억하기 위해

#11 : up !! 위로 이동할경우 x인덱스를 변경할 필요 없기 때문에 dy만 줄여준다. 그리고 move는 3으로 설정함

#12 : while문을 다 돌고 나서 첫번째 행에서 어디 있는지 찾아야 하므로 dx를 출력하면 됨.